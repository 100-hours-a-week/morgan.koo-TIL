# 왜 쓰는가?

- 각각의 컨테이너(파드)를 어떻게 관리할 것인가
- 마스터 노드에서 스케줄러, 컨트롤러, etcd(DB) 등이 유기적으로 작동하여 파드들을 관리

# 주요 컴포넌트

- **kubectl**: Kubernetes의 클러스터와 상호작용하기 위한 메인 커맨드 라인 인터페이스
- **kube-apiserver**: 클러스터의 중심에서 API 요청을 받아 검증하고, 클러스터 상태를 관리하기 위해 API 오브젝트를 생성, 갱신, 삭제하는 역할
- **kube-scheduler**: 클러스터 내 실행할 모든 파드에 대해 실행할 최적의 (워커)노드 선택
- **etcd**: 클러스터의 모든 관리 데이터가 저장되는 곳
- **kubelet**: 파드와 컨테이너의 실행, 파드와 노드의 상태를 API 서버에 보고, 메트릭 수집
- **kube-proxy**: 로드밸런싱, 파드 변경 감지(업데이트), 내부 DNS에 클러스터IP 등록
- **coredns**: 파드가 서비스 이름으로부터 IP주소를 얻기 위해 사용
- **calico-kube-controllers**
- **kubernetes-dashboard**: 웹 대시보드
- **metrics-server**: 클러스터 전체 메트릭 수집

# 쿠버네티스 오브젝트

- 쿠버네티스 조작은 모두 API 기반 - 레포지토리를 활요하여 이미지를 다운받아 컨테이너를 실행하는 구조
- `kubectl`을 통해 마스터 노드 `kub-apiserver`에게 YAML 또는 JSON 형식으로 전송
- **오브젝트**
    - K8s 클러스터 내부의 엔티티 - 파드, 컨트롤러, 서비스 등의 인스턴스
    - API의 리소스 종류에 맞게 설정 및 생성
    - 생성된 오브젝트는 상태가 유지되도록 제어된다
    - 오브젝트 만들 땐 같은 종류의 네임스페이스에서 유일해야 한다
        - k8s 시스템 관련 기능을 수행하는 오브젝트는 `kube-system` 네임스페이스에 만들어진다
- **워크로드**: 컨테이너, 파드, 컨트롤러의 그룹
    - 컨테이너 실행을 관리
- **컨테이너**: 파드 내에 실행해야 하며, 가동 시 이미지 이름, 실행 명령어, 실행 인자, 환경 변수, 리소스 요청/상한 값 설정
- **파드**: 컨테이너를 실행하기 위한 오브젝트
    - 한 개 이상의 컨테이너 실행
- **컨트롤러**: 파드를 제어하는 오브젝트
    - 클라이언트-서버 모델에 적합한 배포 컨트롤러의 경우, 파드의 지정된 개수 유지
    - 배치 처리용 컨트롤러는 배치 처리가 정상 종료될 때까지 재실행 반복
- **노드 > 파드 > 컨테이너** 순으로 개념의 넓이를 생각하면된다

## 파드(Pod)

- 쿠버네티스에서 컨테이너의 최소 기동 단위
- 하나의 목적을 위해 만들어진 컨테이너를 부품처럼 조합할 수 있도록 설계
- IP주소와 포트번호를 공유하며, `localhost`로 서로 통신할 수 있다
- 볼륨을 마운트하여 파일 시스템 공유가 가능하다
- 파드 내 컨테이너는 이미지의 초기 상태로 시작하며 이력은 남지 않는다
- 파드의 IP는 DHCP에 의해 기동 시 부여되고 삭제할 때 회수된다
    - 서브넷 범위 할당을 넓게 하는 것이 좋다
- 파드에 요청 시에는 반드시 서비스 오브젝트를 사용
- **설정(Configuration)**
    - `ConfigMap`, `Secret` 오브젝트 사용
    - 네임스페이스에 저장된 환경변수를 참조
    - **AWS - Secret Manager, Parameter Store** 등을 이용해 CI 스크립트에서 불러올 수도 있다
- **서비스(Service)**
    - 파드와 클라이언트 연결하는 역할
    - 파드가 요청을 받을 수 있도록 대표 IP를 취득하여 내부 DNS에 등록한다
    - 대표 IP로 요청 트래픽에 대한 부하를 분산하여 전송
- **스토리지(Storage)**
    - 파드나 컨테이너는 실행 시에만 일시적으로 존재하기 때문에 중요 데이터는 별도 스토리지에 저장해야 한다
    - Persistant Volume을 사용해 전원이 꺼져도 데이터가 유지되는 스토리지에 저장한다
    - Persistant Volume은 K8s 범위에 포함되지 않는다 → 외부 스토리지 필**요**

<aside>
❗

**노드 & 파드의 개수와 현재 주어진 리소스의 양을 적절히 조율하는 것이 중요하다!**

</aside>

- 파드 생성
    - 명령어로 생성
        
        ```bash
        kubectl run <NAME> --image <IMAGE>
        ```
        
    - Manifest를 이용할 수도 있다(`.yaml`) → Helm Chart
        
        ```yaml
        apiVersion: v1
        kind: pod
        metadata:
        	labels:
        		run: mynginx
        	name: mynginx
        spec:
        	containers:
        	- image: nginx
        		name: mynginx
        ```
        
        ```bash
        kubectl apply -f mynginx.yaml
        
        kubectl describe pods mynginx # 설정 정보 등 상세 설명
        ```
        
    - Manifest 자동 생성
        
        ```bash
        kubectl run ournginx -image nginx --dry-run=client -o yaml > ournginx.yaml
        
        kubectl apply -f mynginx.yaml
        ```
        
- 실행 확인
    
    ```bash
    kubectl get pods
    ```
    
- 파드 삭제
    
    ```bash
    kubectl delete pod <NAME> # yaml 파일을 지워도 됨
    ```
    
- 로그 보기
    
    ```bash
    kubectl logs -f mynginx
    ```
    
    - `-f`: 로그 내용 스트림으로 출력
    - `--previous`: 컨테이너 이전 인스턴스의 로그 - 컨테이너 시작과정에 문제 생겼을 때
- BusyBox를 이용해 파드에 접속할 수 있다 `exec` 명령어와 동일
    - `wget -q -O -<내부 IP>` 로 통신

### 헬스 체크

- 기능 사용을 위해 Manifest에 명시적 설정 필요
- 활성 프로브(`livenessProbe`)
    - 컨테이너 애플리케이션이 정상 실행 중인지 검사
    - 검사 실패 시, 컨테이너를 강제 종료 후 재시작
- 준비 상태 프로브(`readinessProbe`)
    - 컨테이너 애플리케이션이 요청 받을 준비가 되어 있는지 체크
    - 검사 실패 시, **서비스에 의해** 트래픽 전송 중단

### 초기화 전용 컨테이너

- 파드 내 초기화만을 수행하는 컨테이너(`initContainers`)
- 스토리지 마운트할 때 새 디렉토리를 만들어 소유자 변경후 데이터를 저장하는 초기화 처리

### 사이드카 패턴

- 하나의 파드 안에 컨테이너 여러 개를 담아 동시에 실행하는 패턴
- 웹 서버 컨테이너와 최신 컨텐츠를 깃허브에서 다운받는 컨테이너가 묶인 조합 패턴
- 애플리케이션 변경 없이, 사이드카를 붙였다 떼거나 교체하기 쉬운 구성
- 두 컨테이너 간 의존성 관리가 필요하며, 사이드카는 메인 컨테이너보다 뒤에 시작/종료

## 네트워크

- 서비스의 IP주소나 포트번호에 외부에서 접속하려면 NodePort나 로드밸런서 이용
- Flannel: 간단한 L3 네트워크를 노드 간에 구축 - 서브넷 구성
    - Flannel 파드는 데몬셋 컨트롤러에 의해 배포 - 새 노드 추가되면 자동 확장
    - 네트워크 기능만 있으며 접근제어는 없음
- Calico
    - 노드 간 파드 통신에 네트워크 접근 제어 기능 추가 제공
    - 2개 네임스페이스 간 통신 금지하는 접근 제어 설정 가능

## 서비스

- 파드의 IP주소는 가동마다 변경되기 때문에 서비스가 가지는 대표 IP로 접속
- 포트를 `-p` 옵션으로 직접 지정하는 도커와 달리, 쿠버네티스는 서비스를 통해 요청 전달
1. 서비스는 로드밸런서 역할 - 요청을 받기 위해 대표 IP주소 획득
2. 서비스 이름은 내부 DNS에 등록, 클라이언트는 서비스 IP주소를 이름으로 획득
3. **셀렉터**에 지정된 라벨과 일치하는 파드 중 하나로 전달
4. 서비스가 만들어진 후 가동 된 컨테이너는 서비스 환경변수가 자동으로 설정
5. 4개 종류의 서비스 타입: 클라이언트의 범위를 내부/외부 또는 외부IP로 설정 가능
- 대표 IP 주소: 파드의 그룹을 대표하여 요청을 받기위해 가진다
    - 헤드리스인 경우, 파드의 IP주소를 내부 DNS에 직접 설정
- 부하 분산: 대표 IP에 도착한 요청을 셀렉터의 라벨과 일치하는 파드에 전송
    - 셀렉터의 라벨 조건이나 파드에 부여되는 라벨은 유연하게 변경할 수 있다
- 이름 해결: 클러스터 내 파드를 이름으로 접근
- 환경 변수: 애플리케이션 코드에서는 환경 변수로 서비스의 대표 IP 얻을 수 있따
- 서비스 타입: 클라이언트를 고려하여 타입 지정
    - 내부 파드를 대상으로 하는 경우 외부에서 접근할 때를 고려
- 어피니티(Affinity): 부하분산 알고리즘은 랜덤. 파드를 고정하는 경우, 세션 어피니티에 클러스터 IP를 설정
    - HTTP 헤드 내 쿠키 값에 따라 전송되는 파드를 고정하고 싶은 경우, **인그레스** 활용
- 서비스 타입
    - `ClusterIP`: 서비스 생성 시 기본값으로 지정되며, 클러스터 내부 파드에서 **서비스 이름**으로 접근할 수 있다
        - Manifest에 clusterIP:None이라고 지정하면 헤드리스 설정으로 서비스 작동 → 파드에 직접 접근이 가능
        - 파드의 IP주소 변경에 대응하여 부하분산도 이루어지지 않고 최신 상태 유지
    - `NodePort`: `ClusterIP`의 접근 범위 뿐 아니라 k8s 클러스터 외부에서도 **노드의 IP주소**와 포트번호로 접근할 수 있다
        - 노드의 공개 포트가 열린다(30000~32767번)
        - 서비스 생성 시 모든 노드에 지정한 포트가 열린다 - 각 노드가 수령한 요청은 대상 파드에 부하분산
    - `LoadBalancer`: `NodePort`의 접근 범위 뿐 아니라 클러스터 외부에서 **대표 IP 주소**로 접근할 수 있다
        - 파드의 애플리케이션을 외부에 공개 - ClusterIP도 자동할당
    - `ExternalName`: K8s 외부의 DNS 이름을 서비스 이름으로 등록
        - 퍼블릭 클라우드의 데이터베이스나 인공지능 OpenAPI 서비스 등에 접근할 때 사용
        - 서비스의 이름과 외부 DNS 이름의 매핑을 내부 DNS에 설정
- 서비스와 파드의 연결
    - 서비스가 요청을 전송할 파드를 결정할 때 셀렉터의 라벨과 일치하는 파드를 `etcd`로부터 선택
    - 셀렉터와 `Deployment` 파드 템플릿의 `metadata.label` 에 같은 값 설정
    - 셀렉터 값을 바꾸는 것만을 서비스가 전송하는 파드 그룹 유연하게 바꿀 수 있다

## 컨트롤러

- 파드를 제어하는 역할
- 파드에게 부여할 워크로드의 타입에 따라 적절한 컨트롤러를 선택
- **워크로드 - 프론트 엔드 처리**
    - 클라이언트 요청을 직접 받는 워크로드
    - 서버 응답의 지연이 발생하면 안된다
    - 요청에 대응하는 처리를 복수의 파드에서 분담하도록 설계
    - 24시간 무중단 서비스를 제공하며, 새 기능을 빠르게 배포해야 한다
- **워크로드 - 백엔드 처리**
    - 데이터 보존
    - 캐시: 복수 파드에서 데이터 공유(세션 정보 등)
    - 메시징: 비동기 시스템 간 연계 기능(메시지 브로커 등)
    - 마이크로 서비스: 전문적 업무 기능구현(결제, 배송 등)
    - 배치 처리: 긴 처리 시간을 요구하는 기능(기계 학습, 데이터 분석 등)
- **Deployment**
    - 애플리케이션 업데이트 및 배포를 위한 컨트롤러
    - 파드 여러 개로 수평한 클러스터를 구성할 때
    - 가동 중인 파드를 차례대로 교체하거나 규모(개수)를 조절하는 기능
    - ReplicaSet을 관리, Label과 셀렉터를 통해 파드 객체를 확인
    - `kubectl rollout status deployment mydeploy`: 배포 중인 이미지 업데이트 후 상태 확인
    - 재생성 전략(Recreate): Deployment와 관련된 모든 파드를 중지하고, 새로운 버전의 포드를 생성
        - 빠르고 간편하지만, 서비스 다운타임이 발생
        - 테스트 배포에 적합한 방식
    - 롤링 업데이트: 전체의 일부씩 업데이트하여 다운타임 없앤 방법
        - 속도는 느리지만, 정교하고 안정적
        - 업데이트 중의 버전차이로 인한 서비스 중단이 없도록 구성해야 한다
- **StatefulSet**
    - 파드와 퍼시스턴트 볼륨을 조합하여 데이터 보관에 초점 - 번호를 매겨 관리
- **Job**
    - 배치 처리 중인 컨테이너가 정상 종료할 때까지 재실행 반복(Job Controller)
    - STATUS가 Complete여도 비정상 종료일 수 있다 - 재실행 제한에 도달
    - 파드의 실행 횟수, 동시 실행 개수(`parallelism`), 실행 횟수의 상한값 설정 및 파드 삭제 전까지의 로그를 보존
    - 지정한 실행 횟수와 병행 개수에 따라 1개 이상의 파드 실행
    - Job 파드가 삭제된 경우, 다른 노드의 파드에서 재실행
    - Job에 의해 실행된 파드는 Job이 삭제될 때까지 유지되다가 이후에 모두 삭제됨
    - Manifest에 기재된 조건에 따라 마스터 노드의 스케줄러가 적절한 노드를 선택하여 파드 배치
    - 메시지 브로커와의 조합: 컨테이너가 하나의 노드에서는 메모리 용량 제한이 있다
        - 계산 범위를 분할하여 그 파라미터를 메시지 브로커에 보내 여러 파드에서 병렬적으로 계산
    - **단독 파드 구동:** 수평 스케일 불가, 컨테이너 종료 후 삭제 필요
    - **서버 타입 파드 제어:** 수평 스케일, 요구를 계속 대기하며 종료하지 않음, 비정상 종료 시 기동
    - **배치 처리 타입 파드 제어:** 처리가 정상 종료 시 완료, 처리 실패하면 재시도, 병렬 처리 수를 설정하여 시간 단축
- **CronJob**
    - 지정된 시간에 정기적으로 잡 생성
    - 정해진 시간에 잡 컨트롤러 하의 파드를 실행
    - 파드 개수가 정해진 수를 넘어서면 Garbage 수집 컨트롤러가 종료된 파드 삭제
    - 동시 실행과 순차 실행: 복수의 노드 위에서 여러 바드를 동시에 실행하여 배치 처리를 빠르게 완료할 수 있다 - 대량 메일, 파일 변환처리 등
    - 파드의 병행 개수가 너무 많아져도 경쟁 심화로 인해 처리가 느려지는 경우가 발생한다
- **DaemonSet**
    - 모든 노드에서 동일한 파드 실행
    - 네트워크 구성 파드가 데몬셋에 의해 모든 노드에서 실행
    - 시스템 운영의 자동화
- **ReplicaSet**
    - Deployment와 연동하여 기동될 파드의 수 관리
    - 직접 설정보다는 Deployment로 활용
    - 복제할 포드의 셀렉터 정의를 자세히 설정
    - `matchLabels` 옵션을 사용(yaml 파일)
    - `kubectl get rs`: 현재 ReplicaSet 조회
    - `kubectl scale rs —replicas 4 myreplicaset`:복제본 개수 확장(4개)
- **Replication Controller**
- Open Lens라는 툴로 쿠버네티스 클러스터를 GUI로 관리할 수 있다

```bash
kubectl cluster-info # 클러스터의 엔드포인트
kubectl get node/pod # 클러스터를 구성하는 노드/파드 정보 -o wide 옵션으로 더 자세히 볼 수 있다
kubectl run hello-world --image=hello-world -it --restart=Never # 컨테이너 실행 - 백그라운드
kubectl delete pod hello-world # 파드 삭제
```

- `CrashLoopBackOff`: 파드에 문제가 있어 재시작을 반복하고 있다
- `kubectl get deployment`: Deployment 상태 확인
- `kubectl scale deployment sebserver -replicas=5`: 파드 개수를 5개로 유지

## 스토리지

- 추상화된 스토리지를 컨테이너에 마운트한다
- 애플리케이션이 데이터 보존을 위해 내/외부 시스템을 연결하여 퍼시스턴트 볼륨을 이용한다
- 외부 스토리지 사용법
    - 전용 스토리지
    - SDS: 서버를 클러스터링하여 저장 장치로 사용하는 방법
    - 전용 스토리지와 서버 스토리지 조합
- **emptyDir**: 노드의 디스크를 파드가 일시적으로 사용하는 방법 - 데이터를 일시적으로 기록할 때
- **hostPath**: 노드의 디스크를 사용 파드끼리 데이터 공유
- `AWSElasticBlockStore`를 활용하는 것이 클라우드에서의 대표적인 사용법
- **동적 마운트**: 쿠버네티스가 외부 스토리지 시스템의 API를 사용하여 볼륨을 자동으로 준비
- **정적 마운트**: 외부 스토리지 시스템 설정을 직접 수행
- 로그의 경우 스토리지 보다는 DaemonSet으로 S3에 넣는 것이 이상적

## 인그레스

- 서비스와 연결하여 애플리케이션을 외부에 공개하는 오브젝트
- SSL/TLS 암호화나 세션 어피니티 기능을 갖추어 쿠버네티스화 하는데 유용하다
- 기능
    - 공개 URL과 애플리케이션 매핑
    - 복수의 도메인 이름을 가지는 가상 호스팅
    - 요청을 여러 파드에 분산
    - SSL/TLS 암호화 통신 - HTTPS
    - 세션 어피니티
- 기존 로드밸런서를 대체 할 수 있다
- `minikube addons enable ingress`로 인그레스 세팅 가능
- 가상호스트와 서비스를 매핑하는 Manifest 기술
    - 인그레스 Manifest에서는 메타데이터와 어노테이션이 중요
    - 어노테이션에 키-밸류로 기재하여 인그레스 컨트롤러에 명령 전달
    - 여러 인그레스 컨트롤러가 클러스터 내 동작 중인 경우, 어노테이션을 명시적으로 지정해야 함
    - ConfigMap - 미들웨어(NGINX, Apache)의 설장 파일을 컨피그 맵으로 설정하면 파든느 디스크처럼 마운트하여 네임스페이스에서 설정값을 읽어들일 수 있다
- Mondernization
    - 웹에서는 로드밸런서의 세션 어피니티를 사용하는 것이 일반적이다
    - 브라우저는 무상태 프로토콜이므로 서버-클라이언트 통신을 유지할 수 없다
    - 기본적으로 웹은 브라우저를 식별하기 위한 쿠키로 세션정보를 얻어 요청에 대한 처리 수행
    - 로드밸런서가 앞단에 있다 → 세션 정보가 없는 서버에 요청 보내면 문제 발생
        - 이를 해결하는 것이 세션 어피니티

# Horizontal Pod Autoscaler

- 클러스터 내에서 애플리케이션의 부하에 따라 파드의 수를 자동으로 조절해주는 기능
- 오토스케일: CPU, 메모리 사용률에 따라 노드 수 자동으로 조정하는 기능