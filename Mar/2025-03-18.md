# Terraform State

- **Terraform**은 `apply` 명령어를 수행할 때마다 모든 인프라 정보를 저장한 상태 파일을 자동으로 생성한다
    - `terraform.state` 파일
- 상태 파일이 손상되거나 사라지면 실제 인프라와의 **Sync**가 맞지 않게 된다
- Terraform으로 생성한 리소스는 콘솔 등의 방법으로 수정하면 안된다
- 개인 프로젝트를 진행할 땐 변경사항을 유발하는 주체가 본인이므로 문제 발생할 확률이 낮다
- **협업 프로젝트 진행 시엔 동료와 함께 코드 및 상태에 접근할 방법이 필요하고, 상태 파일은 모든 팀원들에게 항상 최신 버전만 보여져야 한다**
    
    → **상태 파일을 저장하는 공유 저장소가 별도로 필요하다!**
    
    - 여러 명이 동시에 업데이트 하는 경우 Lock이 걸리는 경우가 생길 수 있어서 정책을 확립하여 관리해야한다
    - **Terraform** 내장 원격 상태 저장소를 사용하거나, `S3`, `DynamoDB` 등을 상태 저장소로 활용하는 경우도 많다

# 데브옵스와 CI/CD

- 공유 레포지토리 생성(Git) - FE, BE Terraform
    - 브랜치 - `dev`, `main` 로 생성 후 dev에서 `feature` 단위로 뻗어나오도록 하여 → `dev` → `main` 순으로 merge
    - Terraform의 경우, 합쳐지는 브랜치에 따라 `plan`, `apply`를 실행하도록 유도
- 빌드
- 단위 테스트
- 통합 테스트
- 배포
- GitHub Actions 내 Terraform 실행 순서
    - 워크 스페이스 생성
    - `terraform init`
    - `terraform plan` - 변경 사항 확인
    - `terraform apply` - 수동으로 실행하도록 설정하는 것을 권장(Approve)

# IaC 관리법

- 코드 레포지토리 및 빌드 환경이 필요
- 배포 결과물은 인프라 → 테스트 환경 필요(코드의 커밋과 빌드를 통해 배포까지 자동으로)
- 특히 운영(Prod) 환경에서의 변화를 상당히 예민하게 모니터링해야함
    - **자동 approve 금지!!!!!!**
    - **안정성과 보안이 가장 중요**
    - **장애를 어떻게 복구할 것인가**
- 상태 파일의 분리: 개발/운영 환경의 인프라를 독립적으로 관리, 휴먼 에러를 줄이고 자동화된 테스트 및 배포
    - **환경에 따른 분리**: 코드 디렉토리를 환경 따라 물리적으로 분리
    - **구성요소에 따른 분리**: VPC 구성과 Web 서버 구성 인프라를 별도 디렉토리로 구분
    - `mgmt(shared)` 디렉토리: 인프라의 관리 및 설정과 관련된 구성 포함 주로 상태 파일을 관리하는 백엔드 구성 설정
- 읽기 전용 상태를 이용한 참조: Terraform의 공유 저장소에 저장된 상태 파일의 경로를 통해 해당 상태 파일에 저장된 정보를 데이터 소스를 통해 읽기 전용 상태로 볼 수 있다 - **output으로 지정한 출력변수만**
- 환경 분리로 인한 단점도 있다
    - 환경마다 동일 인프라를 구성하는 코드가 중복
    - 변경사항도 환경마다 적용해야하는 수고 → 실수 유발 가능성

# Terraform Module

- 디렉토리 내 구성 파일들의 묶음
- 코드 재사용성을 높여 동일한 구성을 쉽게 재사용 하도록 하기 위해 사용
- 인프라 구성
- 환경 영향
- 버전관리와 일관성 유지 - 다양한 환경에서 일관된 상태관리
- 문서화와 테스트
- `main.tf`에서 모듈을 참조하여 사용
- AWS의 경우, 리소스 별로 모듈을 만들어 `source = “모듈 경로”` 로 사용
- 동일 모듈을 서로 다른 프로젝트에서 참조한 경우 생길 수 있는 문제
    - 버전 충돌
    - 중복 코드
    - 의존성 관리
    - 업데이트와 동기화 문제
    - 보안과 규정 준수의 어려움
    
    → 각 클러스터 모듈을 별도로 관리하기